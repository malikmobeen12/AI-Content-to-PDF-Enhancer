import jsPDF from "jspdf";

/**
 * Main function to generate professional PDF
 */
export const generatePDF = (content, mode, originalText) => {
  // Use A4 format with better formatting
  const doc = new jsPDF({
    orientation: "portrait",
    unit: "mm",
    format: "a4",
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();

  // Professional margins
  const margin = 20; // 20mm margins
  const maxWidth = pageWidth - 2 * margin;
  let yPosition = margin;

  /**
   * Basic helper to add text with formatting
   */
  const addText = (
    text,
    fontSize = 12,
    fontStyle = "normal",
    align = "left",
    color = [0, 0, 0],
    lineHeight = 1.6
  ) => {
    if (!text || text.trim() === "") return;

    // Clean text by removing markdown formatting
    let processedText = text.replace(/\*\*/g, "");

    doc.setFont("helvetica", fontStyle);
    doc.setFontSize(fontSize);
    doc.setTextColor(...color);

    // Convert fontSize from points to mm for consistency
    const fontSizeMM = fontSize * 0.352778;

    const lines = doc.splitTextToSize(processedText, maxWidth);
    const height = lines.length * fontSizeMM * lineHeight;

    if (yPosition + height > pageHeight - margin) {
      doc.addPage();
      yPosition = margin;
    }

    doc.text(lines, align === "center" ? pageWidth / 2 : margin, yPosition, {
      align,
    });
    yPosition += height + fontSizeMM;
  };

  const addCenteredTitle = (text, fontSize = 18) => {
    yPosition += 8;
    addText(text, fontSize, "bold", "center");
    yPosition += 5;
  };

  const addSectionHeader = (text) => {
    yPosition += 8;
    addText(text, 16, "bold");
    doc.setDrawColor(41, 128, 185); // Professional blue color
    doc.setLineWidth(0.5);
    doc.line(margin, yPosition - 2, pageWidth - margin, yPosition - 2);
    yPosition += 5;
  };

  const addParagraph = (text) => {
    if (!text) return;
    addText(text, 12, "normal", "left");
  };

  const addParagraphBold = (text) => {
    if (!text) return;
    addText(text, 12, "bold", "left");
  };

  const addMetadata = (label, value) =>
    addText(`${label}: ${value}`, 11, "normal", "left", [80, 80, 80]);

  const addSeparator = () => {
    yPosition += 5;
    doc.setDrawColor(220, 220, 220);
    doc.setLineWidth(0.5);
    doc.line(margin, yPosition, pageWidth - margin, yPosition);
    yPosition += 5;
  };

  // Normalize status to avoid emoji/font artifacts and stray characters
  const normalizeStatus = (text) => {
    let s = String(text || "");
    s = s
      .replace(/✅/g, " Verified ")
      .replace(/❌/g, " False ")
      .replace(/⚠️|⚠/g, " Partially True ")
      .replace(/❓/g, " Uncertain ");
    // Remove quote-like characters and bullets
    s = s.replace(/[“”"'`]+/g, " ").replace(/[•·]+/g, " ");
    // Remove leading non-letters like stray ampersands or punctuation
    s = s.replace(/^[^A-Za-z]+/, "");
    // Collapse whitespace
    s = s.replace(/\s+/g, " ").trim();
    // Canonical keywords
    if (/verified/i.test(s)) return "Verified";
    if (/false/i.test(s)) return "False";
    if (/partial/i.test(s)) return "Partially True";
    if (/uncertain|unknown|mixed/i.test(s)) return "Uncertain";
    return s || "Uncertain";
  };

  // Header
  addCenteredTitle("AI Content-to-PDF Enhancer", 20);
  addSeparator();

  // Metadata
  const currentDate = new Date().toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });
  addMetadata("Date", currentDate);
  addMetadata("Generated By", "AI Content-to-PDF Enhancer");
  addSeparator();

  // --- Mode Specific Formatting ---
  if (mode === "summarize") {
    formatSummarize(
      doc,
      content,
      addCenteredTitle,
      addSectionHeader,
      addParagraph,
      yPosition,
      margin,
      maxWidth
    );
  } else if (mode === "expand") {
    formatExpand(
      doc,
      content,
      addSectionHeader,
      addParagraph,
      yPosition,
      margin,
      maxWidth
    );
  } else if (mode === "validate") {
    formatValidate(
      doc,
      content,
      addSectionHeader,
      addParagraph,
      addParagraphBold,
      normalizeStatus,
      yPosition,
      margin,
      maxWidth
    );
  }

  // Footer with page numbers
  const pageCount = doc.internal.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(10);
    doc.setTextColor(100, 100, 100);
    const pageText = `Page ${i} of ${pageCount}`;
    doc.text(
      pageText,
      pageWidth - margin - doc.getTextWidth(pageText),
      pageHeight - 12
    );
  }

  // Save file
  const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, "-");
  doc.save(`enhanced-content-${mode}-${timestamp}.pdf`);
};

/** -------------------------
 * Summarize Mode
 * ------------------------- */
const formatSummarize = (
  doc,
  content,
  addCenteredTitle,
  addSectionHeader,
  addParagraph,
  yPosition,
  margin,
  maxWidth
) => {
  addCenteredTitle("AI-Enhanced Summary", 16);

  // Extract sections with better parsing
  let executiveSummary = "";
  let keyPoints = [];
  let currentSection = "";
  let otherSections = {};

  // First try to find structured sections
  const summaryMatch = content.match(/Summary:(.*)/i);
  const keyPointsMatch = content.match(/Key Points:(.*)/i);

  if (summaryMatch) {
    executiveSummary = summaryMatch[1].trim();
    addSectionHeader("Executive Summary");
    addParagraph(executiveSummary);
  } else {
    // If no explicit summary section, use the content as summary
    addSectionHeader("Executive Summary");
    addParagraph(content);
  }

  if (keyPointsMatch) {
    const points = keyPointsMatch[1]
      .split(/[\n•-]/)
      .map((p) => p.trim())
      .filter(Boolean);
    if (points.length) {
      addSectionHeader("Key Points");
      points.forEach((p) => addParagraph("• " + p));
    }
  }

  // Look for additional sections in the content
  content.split("\n").forEach((line) => {
    if (line.match(/^[A-Z][A-Za-z\s]+:$/)) {
      // Detect other section headers (capitalized followed by colon)
      currentSection = line.trim().replace(":", "");
      if (currentSection !== "Summary" && currentSection !== "Key Points") {
        otherSections[currentSection] = "";
      }
    } else if (
      currentSection &&
      otherSections[currentSection] !== undefined &&
      line.trim() !== ""
    ) {
      otherSections[currentSection] += line + " ";
    }
  });

  // Add other sections if they exist
  Object.keys(otherSections).forEach((section) => {
    if (otherSections[section]) {
      addSectionHeader(section);
      addParagraph(otherSections[section]);
    }
  });
};

/** -------------------------
 * Expand Mode
 * ------------------------- */
const formatExpand = (
  doc,
  content,
  addSectionHeader,
  addParagraph,
  yPosition,
  margin,
  maxWidth
) => {
  addSectionHeader("Expanded Content");

  // Process paragraphs, lists, and sections
  let sections = {};
  let currentSection = "Introduction";

  // First identify sections in the content
  content.split(/\n/).forEach((line) => {
    // Check for section headers (capitalized text followed by colon or all caps)
    if (line.match(/^[A-Z][A-Za-z\s]+:$/) || line.match(/^[A-Z\s]{5,}$/)) {
      currentSection = line.trim().replace(":", "");
      sections[currentSection] = "";
    } else if (line.trim() !== "") {
      // Add content to current section
      if (!sections[currentSection]) sections[currentSection] = "";
      sections[currentSection] += line + "\n";
    }
  });

  // If no sections were found, use the default approach
  if (Object.keys(sections).length <= 1) {
    // Split content into paragraphs
    const paragraphs = content.split(/\n\s*\n/).filter((p) => p.trim());
    paragraphs.forEach((p) => addParagraph(p));
  } else {
    // Add each section with proper formatting
    Object.keys(sections).forEach((section) => {
      if (sections[section].trim()) {
        addSectionHeader(section);
        const paragraphs = sections[section]
          .split(/\n\s*\n/)
          .filter((p) => p.trim());
        paragraphs.forEach((p) => {
          // Check if paragraph is a list
          if (p.match(/^[-•*]|^\d+\./m)) {
            const items = p.split(/\n/).filter((i) => i.trim());
            items.forEach((item) => addParagraph(item));
          } else {
            addParagraph(p);
          }
        });
      }
    });
  }

  // Optional: detect "Examples" section if not already present
  if (!sections["Examples"] && /example/i.test(content)) {
    const examplesMatch = content.match(/examples?:\s*(.*)/i);
    if (examplesMatch) {
      addSectionHeader("Examples and Applications");
      const exList = examplesMatch[1]
        .split(/[\n•-]/)
        .map((e) => e.trim())
        .filter(Boolean);
      exList.forEach((e) => addParagraph("• " + e));
    }
  }
};

/** -------------------------
 * Validate Mode without tables (sectioned narrative)
 * ------------------------- */
const formatValidate = (
  doc,
  content,
  addSectionHeader,
  addParagraph,
  addParagraphBold,
  normalizeStatus,
  yPosition,
  margin,
  maxWidth
) => {
  addSectionHeader("Validation Report");

  const lines = content.split("\n");
  const claims = [];
  let current = null;

  // Parse claims from model output (supports markdown variants)
  lines.forEach((line) => {
    const cleanLine = line.replace(/\*\*/g, "");

    if (
      cleanLine.match(/^Claim\s*\d*\s*:\s*/i) ||
      line.match(/^\*\*Claim\s*\d*:\*\*/i)
    ) {
      if (current) claims.push(current);
      current = {
        claim: cleanLine.replace(/^Claim\s*\d*\s*:\s*/i, "").trim(),
        status: "",
        evidence: "",
        source: "",
      };
    } else if (
      (cleanLine.startsWith("Status:") || cleanLine.match(/^Status:/i)) &&
      current
    ) {
      current.status = cleanLine.replace(/Status:/i, "").trim();
    } else if (
      (cleanLine.startsWith("Reasoning:") || cleanLine.match(/^Reasoning:/i)) &&
      current
    ) {
      current.evidence = cleanLine.replace(/Reasoning:/i, "").trim();
    } else if (
      (cleanLine.startsWith("Source:") || cleanLine.match(/^Source:/i)) &&
      current
    ) {
      current.source = cleanLine.replace(/Source:/i, "").trim();
    } else if (
      current &&
      current.claim &&
      cleanLine.trim() &&
      !cleanLine.startsWith("Claim")
    ) {
      if (!current.evidence) current.evidence = cleanLine.trim();
      else current.evidence += " " + cleanLine.trim();
    }
  });
  if (current) claims.push(current);

  if (!claims.length) {
    addParagraph("No claims found.");
    return;
  }

  // Render claims as numbered sections (no tables)
  claims.forEach((c, idx) => {
    addSectionHeader(`Claim ${idx + 1}`);
    if (c.claim) addParagraph(`Claim: ${c.claim}`);
    addParagraphBold(`Status: ${normalizeStatus(c.status)}`);
    addParagraph(`Reasoning: ${c.evidence || "-"}`);
    addParagraph(`Source: ${c.source || "-"}`);
  });

  // Summary
  addSectionHeader("Validation Summary");
  const tally = { Verified: 0, False: 0, "Partially True": 0, Uncertain: 0 };
  claims.forEach((c) => {
    const s = normalizeStatus(c.status);
    if (tally[s] !== undefined) tally[s] += 1;
    else tally.Uncertain += 1;
  });

  addParagraph(`Total Claims Analyzed: ${claims.length}`);
  addParagraph(
    `Verified: ${tally["Verified"]} | False: ${tally["False"]} | Partially True: ${tally["Partially True"]} | Uncertain: ${tally["Uncertain"]}`
  );
};
